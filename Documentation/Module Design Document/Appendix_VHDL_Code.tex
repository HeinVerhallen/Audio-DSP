\addcontentsline{toc}{chapter}{Appendix B: VHDL code}  
\chapter*{Appendix B: VHDL code}
\label{chap:appendix-B-vhdl}

\section*{I2S Decoder}
\addcontentsline{toc}{section}{I2S Decoder}
\begin{lstlisting}
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.NUMERIC_STD.ALL;

ENTITY i2s_decoder IS
	GENERIC (
	d_width : INTEGER := 24); --data width
	PORT (
		nrst : IN std_logic; --active-low reset
		sck : IN std_logic; --serial clock
		ws : IN std_logic; --left right audio word select
		sd : IN std_logic; --serial data
		data_left : OUT std_logic_vector(d_width - 1 DOWNTO 0); --left audio data
		data_right : OUT std_logic_vector(d_width - 1 DOWNTO 0); --right audio data
		o_avail_left : OUT std_logic; --left audio available
		o_avail_right : OUT std_logic --right audio available
	); 
END i2s_decoder;

ARCHITECTURE Behavioral OF i2s_decoder IS
	SIGNAL l_data_int : std_logic_vector(d_width - 1 DOWNTO 0); --internal left audio data
	SIGNAL r_data_int : std_logic_vector(d_width - 1 DOWNTO 0); --internal right audio data

	TYPE t_machine IS (ready, rd_l, rd_r);
	SIGNAL machine : t_machine := ready; --state machine

	SIGNAL bit_cnt : INTEGER := 0; --bit counter

BEGIN
	PROCESS (sck, nrst)
	BEGIN
		IF nrst = '0' THEN
			--Reset state machine and bit counter
			machine <= ready;
			bit_cnt <= 0;
		ELSIF rising_edge(sck) THEN
			CASE machine IS
				--Read left audio
				WHEN rd_l => 
					--Have all bits been read
					IF bit_cnt < d_width THEN
						bit_cnt <= bit_cnt + 1; --increment bit counter
						l_data_int <= l_data_int(l_data_int'HIGH - 1 DOWNTO 0) & sd; --shift serial data in internal left audio data
						data_right <= r_data_int; --output right audio data
					END IF;

					--Write available bits
					o_avail_left <= '0';
					o_avail_right <= '1';
					--Read right audio
				WHEN rd_r => 
					--Have all bits been read
					IF bit_cnt < d_width THEN
						bit_cnt <= bit_cnt + 1; --increment bit counter
						r_data_int <= r_data_int(r_data_int'HIGH - 1 DOWNTO 0) & sd; --shift serial data in internal right audio data
						data_left <= l_data_int; --output left audio data
					END IF;

					--Write available bits
					o_avail_left <= '1';
					o_avail_right <= '0';
				WHEN OTHERS => 
					NULL;
			END CASE;

			--Left audio data is selected and not already reading left audio data
			IF ws = '0' AND machine /= rd_l THEN
				bit_cnt <= 0; --reset bit counter 
				machine <= rd_l; --set state to read left channel
				--Right audio data is selected and not already reading right audio data
			ELSIF ws = '1' AND machine /= rd_r THEN
				bit_cnt <= 0; --reset bit counter
				machine <= rd_r; --set state to read right channel
			END IF;
		END IF;
	END PROCESS;

END Behavioral;
\end{lstlisting}

\section*{I2S Encoder}
\addcontentsline{toc}{section}{I2S Encoder}
\begin{lstlisting}
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.NUMERIC_STD.ALL;

ENTITY i2s_encoder IS
	GENERIC (
	d_width : INTEGER := 24); --data width
	PORT (
		nrst : IN std_logic; --active-low reset
		sck : IN std_logic; --serial clock
		ws : IN std_logic; --left right audio word select
		data_left : IN std_logic_vector(d_width - 1 DOWNTO 0); --left audio data
		data_right : IN std_logic_vector(d_width - 1 DOWNTO 0); --right audio data
		sd : OUT std_logic; --serial data
		i_avail_left : IN std_logic; --left audio available
		i_avail_right : IN std_logic --right audio available
	); 
END i2s_encoder;

ARCHITECTURE Behavioral OF i2s_encoder IS
	SIGNAL l_data_int : std_logic_vector(d_width - 1 DOWNTO 0); --internal left audio data
	SIGNAL r_data_int : std_logic_vector(d_width - 1 DOWNTO 0); --internal right audio data

	TYPE t_machine IS (ready, wr_l, wr_r);
	SIGNAL machine : t_machine := ready; --state machine

	SIGNAL bit_cnt : INTEGER := 0; --bit counter

BEGIN
	PROCESS (sck, nrst)
	BEGIN
		IF nrst = '0' THEN
			--Reset state machine and bit counter
			machine <= ready;
			bit_cnt <= 0;
		ELSIF falling_edge(sck) THEN
			CASE machine IS
				--Write left audio
				WHEN wr_l => 
					--Have all bits been written
					IF bit_cnt < d_width THEN
						bit_cnt <= bit_cnt + 1; --increment bit counter
						l_data_int <= l_data_int(r_data_int'HIGH - 1 DOWNTO 0) & '0'; --shift internal left audio data to the left
						sd <= l_data_int(l_data_int'high); --output MSB of internal left audio data to serial data output
					END IF;

					--If right data is available
					IF (i_avail_right = '1') THEN
						r_data_int <= data_right;
					END IF;

					--Write right audio
				WHEN wr_r => 
					--Have all bits been written
					IF bit_cnt < d_width THEN
						bit_cnt <= bit_cnt + 1; --increment bit counter
						r_data_int <= r_data_int(r_data_int'HIGH - 1 DOWNTO 0) & '0'; --shift internal right audio data to the left
						sd <= r_data_int(r_data_int'high); --output MSB of internal right audio data to serial data output
					END IF;

					--If left data is available
					IF (i_avail_left = '1') THEN
						l_data_int <= data_left;
					END IF;

				WHEN OTHERS => 
					NULL;
			END CASE;
 
			--Left audio data is selected and not already writing left audio data
			IF ws = '0' AND machine /= wr_l THEN
				bit_cnt <= 0; --reset bit counter
				machine <= wr_l; --set state to write left channel
				--Right audio data is selected and not already writing right audio data
			ELSIF ws = '1' AND machine /= wr_r THEN
				bit_cnt <= 0; --reset bit counter
				machine <= wr_r; --set state to write right channel
			END IF;
		END IF;
	END PROCESS;
END Behavioral;
\end{lstlisting}

\section*{I2C master code}
\addcontentsline{toc}{section}{I2C master code}
\begin{lstlisting}
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.std_logic_unsigned.ALL;

ENTITY i2c_master IS
    GENERIC (
        input_clk : INTEGER := 50_000_000; --input clock speed from user logic in Hz
    bus_clk : INTEGER := 400_000); --speed the i2c bus (scl) will run at in Hz
    PORT (
        clk : IN STD_LOGIC; --system clock
        reset_n : IN STD_LOGIC; --active low reset
        ena : IN STD_LOGIC; --latch in command
        addr : IN STD_LOGIC_VECTOR(6 DOWNTO 0); --address of target slave
        rw : IN STD_LOGIC; --'0' is write, '1' is read
        data_wr : IN STD_LOGIC_VECTOR(7 DOWNTO 0); --data to write to slave
        busy : OUT STD_LOGIC; --indicates transaction in progress
        data_rd : OUT STD_LOGIC_VECTOR(7 DOWNTO 0); --data read from slave
        ack_error : BUFFER STD_LOGIC; --flag if improper acknowledge from slave
        sda : INOUT STD_LOGIC; --serial data output of i2c bus
    scl : INOUT STD_LOGIC); --serial clock output of i2c bus
END i2c_master;

ARCHITECTURE logic OF i2c_master IS
    CONSTANT divider : INTEGER := (input_clk/bus_clk)/4; --number of clocks in 1/4 cycle of scl
    TYPE machine IS(ready, start, command, slv_ack1, wr, rd, slv_ack2, mstr_ack, stop); --needed states
    SIGNAL state : machine; --state machine
    SIGNAL data_clk : STD_LOGIC; --data clock for sda
    SIGNAL data_clk_prev : STD_LOGIC; --data clock during previous system clock
    SIGNAL scl_clk : STD_LOGIC; --constantly running internal scl
    SIGNAL scl_ena : STD_LOGIC := '0'; --enables internal scl to output
    SIGNAL sda_int : STD_LOGIC := '1'; --internal sda
    SIGNAL sda_ena_n : STD_LOGIC; --enables internal sda to output
    SIGNAL addr_rw : STD_LOGIC_VECTOR(7 DOWNTO 0); --latched in address and read/write
    SIGNAL data_tx : STD_LOGIC_VECTOR(7 DOWNTO 0); --latched in data to write to slave
    SIGNAL data_rx : STD_LOGIC_VECTOR(7 DOWNTO 0); --data received from slave
    SIGNAL bit_cnt : INTEGER RANGE 0 TO 7 := 7; --tracks bit number in transaction
    SIGNAL stretch : STD_LOGIC := '0'; --identifies if slave is stretching scl
BEGIN
    --generate the timing for the bus clock (scl_clk) and the data clock (data_clk)
    PROCESS (clk, reset_n)
    VARIABLE count : INTEGER RANGE 0 TO divider * 4; --timing for clock generation
    BEGIN
        IF (reset_n = '0') THEN --reset asserted
            stretch <= '0';
            count := 0;
        ELSIF (clk'EVENT AND clk = '1') THEN
            data_clk_prev <= data_clk; --store previous value of data clock
            IF (count = divider * 4 - 1) THEN --end of timing cycle
                count := 0; --reset timer
            ELSIF (stretch = '0') THEN --clock stretching from slave not detected
                count := count + 1; --continue clock generation timing
            END IF;
            CASE count IS
                WHEN 0 TO divider - 1 => --first 1/4 cycle of clocking
                    scl_clk <= '0';
                    data_clk <= '0';
                WHEN divider TO divider * 2 - 1 => --second 1/4 cycle of clocking
                    scl_clk <= '0';
                    data_clk <= '1';
                WHEN divider * 2 TO divider * 3 - 1 => --third 1/4 cycle of clocking
                    scl_clk <= '1'; --release scl
                    IF (scl = '0') THEN --detect if slave is stretching clock
                        stretch <= '1';
                    ELSE
                        stretch <= '0';
                    END IF;
                    data_clk <= '1';
                WHEN OTHERS => --last 1/4 cycle of clocking
                    scl_clk <= '1';
                    data_clk <= '0';
            END CASE;
        END IF;
    END PROCESS;

    --state machine and writing to sda during scl low (data_clk rising edge)
    PROCESS (clk, reset_n)
        BEGIN
            IF (reset_n = '0') THEN --reset asserted
                state <= ready; --return to initial state
                busy <= '1'; --indicate not available
                scl_ena <= '0'; --sets scl high impedance
                sda_int <= '1'; --sets sda high impedance
                ack_error <= '0'; --clear acknowledge error flag
                bit_cnt <= 7; --restarts data bit counter
                data_rd <= "00000000"; --clear data read port
            ELSIF (clk'EVENT AND clk = '1') THEN
                IF (data_clk = '1' AND data_clk_prev = '0') THEN --data clock rising edge
                    CASE state IS
                        WHEN ready => --idle state
                            IF (ena = '1') THEN --transaction requested
                                busy <= '1'; --flag busy
                                addr_rw <= addr & rw; --collect requested slave address and command
                                data_tx <= data_wr; --collect requested data to write
                                state <= start; --go to start bit
                            ELSE --remain idle
                                busy <= '0'; --unflag busy
                                state <= ready; --remain idle
                            END IF;
                        WHEN start => --start bit of transaction
                            busy <= '1'; --resume busy if continuous mode
                            sda_int <= addr_rw(bit_cnt); --set first address bit to bus
                            state <= command; --go to command
                        WHEN command => --address and command byte of transaction
                            IF (bit_cnt = 0) THEN --command transmit finished
                                sda_int <= '1'; --release sda for slave acknowledge
                                bit_cnt <= 7; --reset bit counter for "byte" states
                                state <= slv_ack1; --go to slave acknowledge (command)
                            ELSE --next clock cycle of command state
                                bit_cnt <= bit_cnt - 1; --keep track of transaction bits
                                sda_int <= addr_rw(bit_cnt - 1); --write address/command bit to bus
                                state <= command; --continue with command
                            END IF;
                        WHEN slv_ack1 => --slave acknowledge bit (command)
                            IF (addr_rw(0) = '0') THEN --write command
                                sda_int <= data_tx(bit_cnt); --write first bit of data
                                state <= wr; --go to write byte
                            ELSE --read command
                                sda_int <= '1'; --release sda from incoming data
                                state <= rd; --go to read byte
                            END IF;
                        WHEN wr => --write byte of transaction
                            busy <= '1'; --resume busy if continuous mode
                            IF (bit_cnt = 0) THEN --write byte transmit finished
                                sda_int <= '1'; --release sda for slave acknowledge
                                bit_cnt <= 7; --reset bit counter for "byte" states
                                state <= slv_ack2; --go to slave acknowledge (write)
                            ELSE --next clock cycle of write state
                                bit_cnt <= bit_cnt - 1; --keep track of transaction bits
                                sda_int <= data_tx(bit_cnt - 1); --write next bit to bus
                                state <= wr; --continue writing
                            END IF;
                        WHEN rd => --read byte of transaction
                            busy <= '1'; --resume busy if continuous mode
                            IF (bit_cnt = 0) THEN --read byte receive finished
                                IF (ena = '1' AND addr_rw = addr & rw) THEN --continuing with another read at same address
                                    sda_int <= '0'; --acknowledge the byte has been received
                                ELSE --stopping or continuing with a write
                                    sda_int <= '1'; --send a no-acknowledge (before stop or repeated start)
                                END IF;
                                bit_cnt <= 7; --reset bit counter for "byte" states
                                data_rd <= data_rx; --output received data
                                state <= mstr_ack; --go to master acknowledge
                            ELSE --next clock cycle of read state
                                bit_cnt <= bit_cnt - 1; --keep track of transaction bits
                                state <= rd; --continue reading
                            END IF;
                        WHEN slv_ack2 => --slave acknowledge bit (write)
                            IF (ena = '1') THEN --continue transaction
                                busy <= '0'; --continue is accepted
                                addr_rw <= addr & rw; --collect requested slave address and command
                                data_tx <= data_wr; --collect requested data to write
                                IF (addr_rw = addr & rw) THEN --continue transaction with another write
                                    sda_int <= data_wr(bit_cnt); --write first bit of data
                                    state <= wr; --go to write byte
                                ELSE --continue transaction with a read or new slave
                                    state <= start; --go to repeated start
                                END IF;
                            ELSE --complete transaction
                                state <= stop; --go to stop bit
                            END IF;
                        WHEN mstr_ack => --master acknowledge bit after a read
                            IF (ena = '1') THEN --continue transaction
                                busy <= '0'; --continue is accepted and data received is available on bus
                                addr_rw <= addr & rw; --collect requested slave address and command
                                data_tx <= data_wr; --collect requested data to write
                                IF (addr_rw = addr & rw) THEN --continue transaction with another read
                                    sda_int <= '1'; --release sda from incoming data
                                    state <= rd; --go to read byte
                                ELSE --continue transaction with a write or new slave
                                    state <= start; --repeated start
                                END IF; 
                            ELSE --complete transaction
                                state <= stop; --go to stop bit
                            END IF;
                        WHEN stop => --stop bit of transaction
                            busy <= '0'; --unflag busy
                            state <= ready; --go to idle state
                    END CASE; 
                ELSIF (data_clk = '0' AND data_clk_prev = '1') THEN --data clock falling edge
                    CASE state IS
                        WHEN start => 
                            IF (scl_ena = '0') THEN --starting new transaction
                                scl_ena <= '1'; --enable scl output
                                ack_error <= '0'; --reset acknowledge error output
                            END IF;
                        WHEN slv_ack1 => --receiving slave acknowledge (command)
                            IF (sda /= '0' OR ack_error = '1') THEN --no-acknowledge or previous no-acknowledge
                                ack_error <= '1'; --set error output if no-acknowledge
                            END IF;
                        WHEN rd => --receiving slave data
                            data_rx(bit_cnt) <= sda; --receive current slave data bit
                        WHEN slv_ack2 => --receiving slave acknowledge (write)
                            IF (sda /= '0' OR ack_error = '1') THEN --no-acknowledge or previous no-acknowledge
                                ack_error <= '1'; --set error output if no-acknowledge
                            END IF;
                        WHEN stop => 
                            scl_ena <= '0'; --disable scl
                        WHEN OTHERS => 
                            NULL;
                    END CASE;
                END IF;
            END IF;
        END PROCESS; 

        --set sda output
        WITH state SELECT
        sda_ena_n <= data_clk_prev WHEN start, --generate start condition
                        NOT data_clk_prev WHEN stop, --generate stop condition
                        sda_int WHEN OTHERS; --set to internal sda signal 
    
        --set scl and sda outputs
        scl <= '0' WHEN (scl_ena = '1' AND scl_clk = '0') ELSE 'Z';
        sda <= '0' WHEN sda_ena_n = '0' ELSE 'Z';
    
END logic;
\end{lstlisting}

\section*{State-space band-pass filter}
\addcontentsline{toc}{section}{State-space band-pass filter}
\begin{lstlisting}
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use ieee.fixed_pkg.all;
use IEEE.math_real.all;

entity BPF_filter is
    GENERIC(
        d_width     : integer := 8;
        freq_sample : integer := 192000;
        freq_res    : integer := 400;                         --resonance frequency
        gain        : integer := 1);
    Port ( 
        d_in    : in  std_logic_vector(d_width-1 downto 0); --input data
        nrst    : in  std_logic;                            --active-low reset
        i_avail : in  std_logic;                            --input data available
        d_out   : out std_logic_vector(d_width-1 downto 0) --output data
        o_avail : out std_logic                             --output data available
        ); 
end BPF_filter;

architecture Behavioral of BPF_filter is
    function compress (
        a       : in unsigned;  --Value to be compressed
        d_width : in integer    --The size where the input value needs to be compressed to
    ) return unsigned is
        constant max            : unsigned(d_width-1 downto 0) := (others => '1');  --minimal value for input value to be shifted

        variable temp_mirror    : unsigned(0 to a'length-1);        --mirrored temp value
        variable shiftVal       : unsigned(a'length-1 downto 0);    --value that the input needs to be shifted

        variable temp_result    : unsigned(a'length*2-1 downto 0);  --temporary result
        variable result         : unsigned(d_width-1 downto 0);     --final result
    begin
        --Input is larger than maximum 
        if (a > max) then
            --Mirror input
            for i in 0 to a'length-1 loop
                temp_mirror(i) := a(i);
            end loop;

            --Compute amount of shifts for the value to line up correctly
            shiftVal := temp_mirror and not (temp_mirror - "1");

            --Shift input value by computed shift value
            temp_result := a * shiftVal;

            --Resize and set d_width amount of MSB to result
            result := resize(temp_result(a'length-1 downto a'length-d_width), d_width);
        else
            --Set d_width amount of input bits to result
            result := a(d_width-1 downto 0);
        end if;

        return result;
    end compress;

    function compress (
        a       : in signed;    --Value to be compressed
        d_width : in integer    --The size where the input value needs to be compressed to
    ) return signed is
        constant max_signed     : unsigned(d_width-2 downto 0) := (others => '1');  --minimal value for a negative valued input to be shifted
        constant max_unsigned   : unsigned(d_width-1 downto 0) := (others => '1');  --minimal value for a positive valued input to be shifted

        variable temp_a         : unsigned(a'length-1 downto 0);    --temporary input value
        variable temp_mirror    : unsigned(0 to a'length-1);        --mirrored temp value
        variable shiftVal       : unsigned(a'length-1 downto 0);    --value that the input needs to be shifted

        variable temp_result    : signed(a'length*2-1 downto 0);    --temporary result
        variable result         : signed(d_width-1 downto 0);       --final result
    begin
        --Convert signed input to unsigned value
        temp_a := unsigned(a);

        --If signed make unsigned
        if (temp_a(a'left) = '1') then 
            temp_a := (not temp_a) + 1; 
        end if;

        if ((a(a'left) = '0' and temp_a > max_unsigned) or (a(a'left) = '1' and temp_a > max_signed)) then
            --Mirror temp
            for i in 0 to a'length-1 loop
                temp_mirror(i) := temp_a(i);
            end loop;

            --Compute amount of shifts for the value to line up correctly
            shiftVal := ((temp_mirror and not (temp_mirror - 1)) / 2);

            --Correct for zero value
            if (shiftVal < 1) then
                shiftVal := shiftVal + 1;
            end if;

            --Shift input value by computed shift value
            temp_result := a * signed(shiftVal);

            --Resize and set d_width amount of MSB to result
            result := resize(temp_result(a'length-1 downto a'length-d_width), d_width);
        --Input is signed
        elsif a(a'left) = '1' then
            --Set d_width amount of input bits to result
            result := a(d_width-1 downto 0);

        --Input is unsigned
        else
            --Set d_width amount of input bits minus sign position bit to result
            result := '0' & a(d_width-2 downto 0);
        end if;

        return result;
    end compress;

    constant twoPI : real := 6.283185;

    constant order : integer := 2;
    type matrix_A is array (0 to 2*order-1) of real;
    type matrix_B is array (0 to order-1) of real;

    type matrix_Ad is array (0 to 2*order-1) of signed(31 downto 0);
    type matrix_Bd is array (0 to order-1) of signed(31 downto 0);

    type m_temp_state is array (0 to order-1) of signed(63 downto 0);

    signal state : matrix_Bd := (to_signed(0, 32), to_signed(0, 32));
    signal output : unsigned(63 downto 0);

    --signal test_output  : unsigned(31 downto 0);
    signal test_output  : integer;
    signal test_real    : real := -20480.5364;

    signal test_Ad : matrix_Ad;
    signal test_Bd : matrix_Bd;

begin
    process(ready, nrst)                       
        variable coef_A : matrix_A := (-twoPI*real(freq_res), 0.0, -real(gain)*twoPI*real(freq_res), -twoPI*real(freq_res));
        variable coef_B : matrix_B := (twoPI*real(freq_res), real(gain)*twoPI*real(freq_res));
        variable coef_C : matrix_B := (0.0, 1.0); --can use the same array size as B
        
        variable coef_A_pow      : matrix_A;
        variable coef_temp_A_pow : matrix_A;
        variable identity_matrix : matrix_A := (1.0, 0.0, 0.0, 1.0);

        variable factorial          : real := 1.0;
        variable sample_time        : real := 1.0/real(freq_sample);
        variable sample_time_pow    : real := sample_time;

        variable fl_coef_Ad : matrix_A := identity_matrix;
        variable fl_coef_Bd : matrix_B := (coef_B(0)*sample_time, coef_B(0)*sample_time);

        variable coef_Ad    : matrix_Ad;
        variable coef_Bd    : matrix_Bd;

        variable temp_state : m_temp_state;
        variable temp_test  : signed(63 downto 0);
        variable temp_input : unsigned(7 downto 0) := "00011101";

        variable shift17    : unsigned(31 downto 0) := (17 => '1', others => '0');
        variable shift15    : unsigned(31 downto 0) := (15 => '1', others => '0');
        
    begin
        if (nrst = '0') then    --reset is active
            --Initialize discrete coefficient matrices
            coef_A_pow      := coef_A;
            fl_coef_Ad      := identity_matrix;
            fl_coef_Bd      := (coef_B(0)*sample_time, coef_B(0)*sample_time);

            factorial       := 1.0;
            sample_time_pow := sample_time;

            --Compute AT + A^2*T^2/2 + ...
            compute_Ad_and_Bd : for i in 0 to 10 loop

                --Compute Resulting Ad and Bd
                for j in 0 to 1 loop
                    --Compute Bd
                    fl_coef_Bd(j) := fl_coef_Bd(j) + (((coef_A_pow(j*2)*coef_B(0) + coef_A_pow(j*2+1) * coef_B(1))*sample_time_pow*sample_time) / (factorial * real(i+2)));

                    for k in 0 to 1 loop
                        --Compute Ad
                        fl_coef_Ad(j*2+k) := fl_coef_Ad(j*2+k) + ((coef_A_pow(j*2+k)*sample_time_pow)/factorial);
                    end loop;
                end loop;

                --Compute A to the power of n in temporary matrix 
                for j in 0 to 1 loop
                    for k in 0 to 1 loop
                        coef_temp_A_pow(j*2+k) := coef_A_pow(j*2)*coef_A(k) + coef_A_pow(j*2+1)*coef_A(2+k);
                    end loop;
                end loop;

                --Copy temp to power of A matrix
                coef_A_pow := coef_temp_A_pow;

                --Compute T^n and n!
                sample_time_pow := sample_time_pow*sample_time;
                factorial       := factorial * real(i+2);

            end loop compute_Ad_and_Bd;

            --Convert float coefficients to fixed point
            for j in 0 to 1 loop
                fl_coef_Bd(j)   := fl_coef_Bd(j)*real(to_integer(shift17));
                fl_coef_Bd(j)   := fl_coef_Bd(j) / 2.0 + (fl_coef_Bd(j) - ((fl_coef_Bd(j)/2.0) * 2.0));
                coef_Bd(j)      := to_signed(integer(fl_coef_Bd(j)), 32);

                for k in 0 to 1 loop 
                    fl_coef_Ad(j*2+k)   := fl_coef_Ad(j*2+k)*real(to_integer(shift17));
                    fl_coef_Ad(j*2+k)   := fl_coef_Ad(j*2+k) / 2.0 + (fl_coef_Ad(j*2+k) - ((fl_coef_Ad(j*2+k)/2.0) * 2.0));
                    coef_Ad(j*2+k)      := to_signed(integer(fl_coef_Ad(j*2+k)), 32);
                end loop;
            end loop;
        elsif (rising_edge(ready)) then     --reset is inactive and sample is ready

            test_Ad <= coef_Ad;
            test_Bd <= coef_Bd;

            for i in 0 to 1 loop
                temp_state(i) := compress(coef_Ad(i*2)*state(0) + coef_Ad(i*2+1)*state(1) + coef_Bd(i)*resize(signed(d_in), 32), 64);
                temp_test := signed(temp_state(i));

                --if (temp_state(i) >= 0) then
                if (temp_test(temp_test'left) = '0') then
                    temp_state(i) := temp_state(i) / 32768;
                    temp_test := temp_test / 32768;

                else
                    temp_state(i) := temp_state(i) / 32768;
                    temp_test := temp_test / 32768;
                end if;

                temp_state(i) := temp_state(i) / 32768;
                temp_state(i) := compress(temp_state(i)/2 + (temp_state(i) - ((temp_state(i)/2) * 2)), temp_state(i)'length);
                state(i) <= compress(temp_state(i), 32);
            end loop;

            d_out <= std_logic_vector(compress(temp_state(1), d_width));
        end if;
    end process;
end Behavioral;
\end{lstlisting}

\section*{Sinewave generator}
\addcontentsline{toc}{section}{Sinewave generator}
\begin{lstlisting}
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity sinewave_generator is
    GENERIC(
        d_width         : integer := 24;
        mclk_freq       : integer := 50000000;
        sample_freq     : integer := 192000;
        desired_freq    : integer := 1000);
    Port (
        mclk        : in  std_logic;
        sinewave    : out std_logic_vector(d_width-1 downto 0);
        valid       : out std_logic
        ); 
end sinewave_generator;

architecture Behavioral of sinewave_generator is
begin
    process(mclk)
        constant PI     : real := 3.14159265;
        constant limit  : real := PI - (2.0*PI/real(sample_freq));
        constant step   : real := 2.0*PI/real(sample_freq);
        variable index  : real := -PI;
        variable z      : real;

        type t_factorials is array (0 to 10) of real;
        constant factorials : t_factorials := (1.0/6.0, 1.0/120.0, 1.0/5040.0, 1.0/362880.0, 1.0/39916800.0, 1.0/6227020800.0, 1.0/1307674368000.0, 1.0/355687428100000.0, 1.0/121645100400000000.0, 1.0/51090942170000000000.0, 1.0/25852016740000000000000.0);

        variable temp_sine      : real := 0.0;
        variable resized_sine   : real := 0.0;
        variable unsigned_sine  : signed(d_width-1 downto 0) := (others => '0');
        variable shifter        : unsigned(d_width-1 downto 0) := (d_width-1 => '0', others => '1');

        constant divider        : integer := mclk_freq/sample_freq;
        variable tick_counter   : integer := 0;

    begin
        if rising_edge(mclk) then
            tick_counter := tick_counter + 1;

            if (tick_counter >= divider) then
                tick_counter := 0;

                z := index * index;

                temp_sine := -index * (1.0+z*(-factorials(0)+z*(factorials(1) + z*(-factorials(2)+z*(factorials(3) + z*(-factorials(4) + z*(factorials(5) + z*(-factorials(6) + z*(factorials(7) + z*(-factorials(8) + z*(factorials(9))))))))))));

                resized_sine    := temp_sine * real(to_integer(shifter));
                unsigned_sine   := to_signed(integer(temp_sine * real(to_integer(shifter))), d_width);

                sinewave    <= std_logic_vector(unsigned_sine);
                valid       <= '1';

                index := index + (step * real(desired_freq));
                if (index >= limit) then
                    index := -PI;
                end if;
            else
                valid <= '0';
            end if;
        end if;
    end process;
end Behavioral;
\end{lstlisting}

\section*{Volume control effect}
\addcontentsline{toc}{section}{Volume control effect}
\begin{lstlisting}
    library IEEE;
    use IEEE.STD_LOGIC_1164.ALL;
    use IEEE.NUMERIC_STD.ALL;
    use ieee.fixed_pkg.all;
    use IEEE.math_real.all;
    
    entity volume_eff_v2 is
        GENERIC(
            d_width     : integer := 24);         --data width of input and output
        Port ( 
            d_in    : in  std_logic_vector(d_width-1 downto 0); --input data
            param   : in  std_logic_vector(6 downto 0);         --gain parameter
            d_out   : out std_logic_vector(d_width-1 downto 0) --output data
            ); 
    end volume_eff_v2;
    
    architecture Behavioral of volume_eff_v2 is
        signal gain : sfixed(31 downto -32) := to_sfixed(2.0, 31, -32);
    
    begin
        process(d_in)
        begin
            d_out <= std_logic_vector(to_signed(resize(to_sfixed(signed(d_in), 31, -32) * gain, 31, -32), d_width));
        end process;
    
        process(param)
            type t_lookup_gain is array (0 to 127) of sfixed(31 downto -32);
            --Lookup gain ranging from -87dB to 40dB
            constant lookup_gain : t_lookup_gain := ();     --too large to put in report
        begin
            gain <= lookup_gain(to_integer(unsigned(param)));
        end process;
    end Behavioral;
\end{lstlisting}

\section*{Distortion effect}
\addcontentsline{toc}{section}{Distortion effect}

\section*{rotary decoder}
\addcontentsline{toc}{section}{rotary decoder}
\begin{lstlisting}
    library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    
    entity Decoder is
        port(
            Nrst		: in  std_logic;
            Clk     	: in  std_logic;
            A 			: in  std_logic;
            B 			: in  std_logic;
            LeftOut 	: out std_logic;
            RightOut 	: out std_logic
        );
    end Decoder;
    
    
    architecture RTL of Decoder is
    
    type SM_LR is (IDLE, r1, r2, r3, r4, l1, l2, l3, l4);
    signal SM 		: SM_LR := IDLE;
    signal SM_next 	: SM_LR := IDLE;
    
    begin
    
    decoder : process( SM, A, B )
    begin
            case SM is
                when IDLE 	=> if A = '1' THEN SM_next <= r1; elsif B = '1' then SM_next <= l1; else SM_next <= IDLE; end if;
                when r1 	=> if B = '1' THEN SM_next <= r2; else SM_next <= r1; end if;
                when r2 	=> if A = '1' THEN SM_next <= r3; else SM_next <= r2; end if;
                when r3 	=> if B = '1' THEN SM_next <= r4; else SM_next <= r3; end if;
                when r4		=> SM_next <= IDLE;
                when l1 	=> if A = '1' THEN SM_next <= l2; else SM_next <= l1; end if;
                when l2 	=> if B = '1' THEN SM_next <= l3; else SM_next <= l2; end if;
                when l3 	=> if A = '1' THEN SM_next <= l4; else SM_next <= l3; end if;
                when l4		=> SM_next <= IDLE;
                when OTHERS => SM_next <= IDLE;
            end case;
    end process decoder;
    
    process( Nrst, clk )
    begin
        if Nrst = '0' then
            SM <= IDLE;
        elsif rising_edge(clk) then
            SM <= SM_next;
        end if;
    end process;
    
    process( SM )
        --variable counter : integer := 0;
    begin
            case SM is
                when IDLE=> rightOut <= '0'; leftout <= '0';
                when r1	=> rightOut <= '0'; leftout <= '0';
                when r2	=> rightOut <= '0'; leftout <= '0';
                when r3	=> rightOut <= '0'; leftout <= '0';
                when r4	=> rightOut <= '1'; leftout <= '0';
                when l1	=> rightOut <= '0'; leftOut <= '0';
                when l2	=> rightOut <= '0'; leftOut <= '0';
                when l3	=> rightOut <= '0'; leftOut <= '0';
                when l4	=> rightOut <= '0'; leftOut <= '1';
            end case;
    end process;                                                                   
    end architecture RTL;
\end{lstlisting}

\section*{debounce}
\addcontentsline{toc}{section}{debounce}
\begin{lstlisting}
    library ieee;
    use IEEE.std_logic_1164.all;
    use IEEE.numeric_std.all;
    
    entity debounce is
        port (
            Nrst	: in  std_logic;
            clk		: in  std_logic;
            input	: in  std_logic;
            output	: out std_logic
        );
    end entity debounce;
    
    architecture rtl of debounce is
    begin
    debounce: process(clk, Nrst, input)
        variable counter : integer := 0;
        variable state : std_logic := '1'; 
    begin
        if Nrst = '0' then
            output <= '0';
            counter := 0;
            state := '1';
        elsif rising_edge(clk) then
            if state = '0' then
                counter := counter + 1;
                if counter = 300000 then
                    output <= '1';
                else
                    output <= '0';
                end if;
            else
                counter := 0;
            end if;
            if state = not input then
                state := input;
            end if;
        end if;
    end process debounce;	
    end architecture rtl;
\end{lstlisting}

\section*{double debounce}
\addcontentsline{toc}{section}{double debounce}
\begin{lstlisting}
    library ieee;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity doubledebounce is
	port (
		Nrst	: in  std_logic;
		clk		: in  std_logic;
		input	: in  std_logic;
		output	: out std_logic
	);
end entity doubledebounce;

architecture rtl of doubledebounce is
begin
debounce: process(clk, Nrst, input)
	 variable counter : integer := 0;
    variable state : std_logic := '1';
	 variable changed : integer range 0 to 1 := 0; 
begin
    if Nrst = '0' then
        output <= '0';
        changed := 0;
        state := '1';
		  counter := 0;
    elsif rising_edge(clk) then
		if state = not input then
			state := input;
			changed := 1;
		end if;
	 
		if changed = 1 then
			counter := counter + 1;
			if counter = 50000 then
				output <= '1';
				counter := 0;
				changed := 0;
			else
				output <= '0';
			end if;
		else
			output <= '0';
		end if;
	end if;
end process debounce;	
end architecture rtl;
\end{lstlisting}

\section*{Menu controller}
\addcontentsline{toc}{section}{menu controller}
\begin{lstlisting}
    library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.NUMERIC_STD.all;

entity UIController is
generic(
	bufferSize 			: integer := 64;
	numberOfPages 		: integer := 28;
	numberOfChannels	: integer := 6;
	maxElements			: integer := 7;
	settingsData		: integer := 143;
	numberOfEffects		: integer := 5;
	effectRegisterSize	: integer := 32
);

port(
	Nrst		: in std_logic;
	Clk			: in std_logic;
	Dataready	: in std_logic;
	RXData		: in std_logic_vector(7 downto 0);
	TXDone		: in std_logic;
	leftInput	: in std_logic;
	rightInput	: in std_logic;
	pressInput	: in std_logic;
	loadbyte	: out std_logic;
	TXData		: out std_logic_vector(7 downto 0);
	param1		: out std_logic_vector(15 downto 0);
	button		: out std_logic_vector(3 downto 0);
	parameters	: OUT std_logic_vector(numberOfEffects*effectRegisterSize*numberOfChannels-1 downto 0) 	--ch1(159 downto 0). CH2(319 downto 160), CH3(479 downto 320), CH4(639 downto 480), CH5(799 downto 640), CH6(959 downto 800),
	--inputselect	: OUT std_logic_vector(17 downto 0)		--CH1(2 downto 0), CH2(5 downto 3), CH3(8 downto 6), CH4(11 downto 9), CH5(14 downto 12), CH16(17 downto 15), 
);

end entity UIController;

architecture RTL OF UIcontroller is

type t_SM_TX is (IDLE, LOAD, BUSY);
type t_SM_RX is (RECEIVING, StoP1, StoP2, StoP3, FULL);
type FifoBuffer 	is ARRAY(bufferSize-1 downto 0) 					OF std_logic_vector(7 downto 0);
type pageArray 		is ARRAY(0 to numberOfPages-1, 0 to maxElements-1)	OF integer RANGE 0 to 256;
type effectArray 	is ARRAY(0 to numberofChannels-1)					OF unsigned(31 downto 0);
type routingArray	is ARRAY (0 to numberOfChannels-1)					OF unsigned(15 downto 0);
type stepArray		is ARRAY (0 to 11)									OF unsigned(31 downto 0);

constant volumepos 	: integer := 0;
constant eqpos		: integer := 1;
constant gainpos	: integer := 2;
constant delaypos	: integer := 3;
constant reverbpos	: integer := 4;

constant homeScreen		: integer := 000;
constant signalRouting	: integer := 001;
constant inputSelect1	: integer := 002;
constant inputSelect2	: integer := 003;
constant outputrouting1	: integer := 004;
constant outputrouting2	: integer := 005;
constant outputrouting3	: integer := 006;
constant firstchannel1	: integer := 007;
constant firstchannel2	: integer := 008;
constant secondchannel1	: integer := 009;
constant secondchannel2 : integer := 010;
constant effects1		: integer := 011;
constant effects2		: integer := 012;
constant effectselect1	: integer := 013;
constant effectselect2	: integer := 014;
constant gain			: integer := 015;
constant jackgain		: integer := 016;
constant equalizer		: integer := 017;
constant delay			: integer := 018;
constant reverb			: integer := 019;
constant channelvolume	: integer := 020;

constant presets		: integer := 021;
constant loadpreset1	: integer := 022;
constant loadpreset2	: integer := 023;
constant loadconfirm	: integer := 024;
constant adjustpreset1	: integer := 025;
constant adjustpreset2	: integer := 026;
constant adjustconfirm	: integer := 027;


constant channel1		: integer := 94; 
constant channel2		: integer := 95; 
constant channel3		: integer := 96; 
constant channel4		: integer := 97; 
constant channel5		: integer := 98; 
constant channel6		: integer := 99;

constant RCA1			: integer := 100;
constant RCA2			: integer := 101;
constant TRS1			: integer := 102;
constant TRS2			: integer := 103;
constant XLR1			: integer := 104;
constant XLR2			: integer := 105;
constant USB			: integer := 106;
	
constant firstCH1		: integer := 107;
constant firstCH2		: integer := 108;
constant firstCH3		: integer := 109;
constant firstCH4		: integer := 110;
constant firstCH5		: integer := 111;
constant firstCH6		: integer := 112;
constant secondCH1		: integer := 113;
constant secondCH2		: integer := 114;
constant secondCH3		: integer := 115;
constant secondCH4		: integer := 116;
constant secondCH5		: integer := 117;
	
constant CH1			: integer := 118;
constant CH2			: integer := 119;
constant CH3			: integer := 120;
constant CH4			: integer := 121;
constant CH5			: integer := 122;
constant CH6			: integer := 123;
constant gainselect		: integer := 124;
constant channelgain	: integer := 125;
constant inputgain		: integer := 126;
constant f0				: integer := 127;
constant f1				: integer := 128;
constant f2				: integer := 129;
constant f3				: integer := 130;
constant f4				: integer := 131;
constant dtime			: integer := 132;
constant feedback		: integer := 133;
constant mix			: integer := 134;
constant chvolume		: integer := 135;
constant rlength		: integer := 136;
constant rsize			: integer := 137;
	
constant preset1		: integer := 138;
constant preset2		: integer := 139;
constant preset3		: integer := 140;
constant preset4		: integer := 141;
constant preset5		: integer := 142;
constant preset6		: integer := 143;
constant changepreset1	: integer := 144;
constant changepreset2	: integer := 145;
constant changepreset3	: integer := 146;
constant changepreset4	: integer := 147;
constant changepreset5	: integer := 148;
constant changepreset6	: integer := 149;
constant confirmload	: integer := 150;
constant confirmadjust	: integer := 151;
constant functions : pageArray := (
	(signalRouting	,effects1		,presets		,0				,0				,0				,3),--0  homeScreen
	(inputSelect1	,firstChannel1	,homeScreen		,0				,0				,0				,3),--1  signalRouting
	(channel1		,channel2		,channel3		,inputSelect2	,signalRouting	,0				,5),--2  inputSelect1
	(channel4		,channel5		,channel6		,inputSelect1	,signalRouting	,0				,4),--3  inputSelect2
	(RCA1			,RCA2			,TRS1			,outputrouting2	,inputSelect1	,0				,5),--4  outputrouting1
	(TRS2			,XLR1			,XLR2			,outputrouting3	,inputSelect1	,0				,5),--5  outputrouting2
	(USB			,outputrouting3	,inputSelect1	,0				,0				,0				,3),--6  outputrouting3
	(firstCH1		,firstCH2		,firstCH3		,firstchannel2	,signalRouting	,0				,5),--7  firstchannel1
	(firstCH4		,firstCH5		,firstCH6		,firstchannel1	,signalRouting	,0				,5),--8  firstchannel2
	(secondCH1		,secondCH2		,secondCH3		,secondchannel2	,firstchannel1	,0				,5),--9  secondchannel1
	(secondCH4		,secondCH5		,secondchannel1	,firstchannel1	,0				,0				,4),--10 secondchannel2
	(CH1			,CH2			,CH3			,effects2		,homescreen		,0				,5),--11 effects1
	(CH4			,CH5			,CH6			,effects1		,homescreen		,0				,5),--12 effects2
	(equalizer		,gainselect		,delay			,effectselect2	,effects1		,0				,5),--13 effectselect1
	(reverb			,channelvolume	,effectselect1	,effects1		,0				,0				,4),--14 effectselect2
	(channelgain	,effectselect1	,0				,0				,0				,0				,2),--15 gain
	(inputgain		,channelgain	,effectselect1	,0				,0				,0				,3),--16 jackgain
	(f0				,f1				,f2				,f3				,f4				,effectselect1	,6),--17 equalizer
	(dtime			,feedback		,mix			,effectselect1	,0				,0				,4),--18 Delay
	(rLength		,rSize			,effectselect1	,0				,0				,0				,3),--19 Reverb
	(chvolume		,effectselect1	,0				,0				,0				,0				,2),--20 channelvolume
	(loadpreset1	,adjustpreset1	,homescreen		,0				,0				,0				,3),--21 presets
	(preset1		,preset2		,preset3		,loadpreset2	,presets		,0				,4),--22 loadpreset1
	(preset4		,preset5		,preset6		,loadpreset1	,presets		,0				,5),--23 loadpreset2
	(confirmLoad	,loadpreset1	,0				,0				,0				,0				,2),--24 loadconfirm
	(changepreset1	,changepreset2	,changepreset3	,adjustpreset2	,presets		,0				,4),--25 adjustpreset1
	(changepreset4	,changepreset5	,changepreset6	,adjustpreset1	,presets		,0				,5),--26 adjustpreset2
	(confirmAdjust	,adjustpreset1	,0				,0				,0				,0				,2) --27 adjustconfirm
	);

constant stepsize : stepArray := ("00000000000000000000000011111111", "00000000000000000000000000111111", "00000000000000000000000000111111", "00000000000000000000000000111111", "00000000000000000000000000111111", "00000000000000000000000000111111", "00000000000000000000111111111111", "00000000000000000000001111111111", "00000000000000000000001111111111", "00000000000000001111111111111111", "00000000000000001111111111111111", "11111111111111111111111111111111");

SIGNAL SM_TX 		: t_SM_TX := IDLE;
SIGNAL SM_RX 		: t_SM_RX := RECEIVING;

procedure updateregister(
	effect 											: inout effectArray;
	size, offset, pressedfunction, activechannel	: in 	integer;
	count											: in	unsigned(31 downto 0)
) is

	--give x a good descriptive name
	constant x : integer := 126;
	variable maxcount : unsigned(31 downto 0);

begin
	maxcount := stepsize(pressedfunction-126);
 	if effect(activechannel)(offset+size-1 downto offset) > maxcount  then
		effect(activechannel)(offset+size-1 downto offset) := maxcount(size-1 downto 0);
	elsif effect(activechannel)(offset+size-1 downto offset) = maxcount and to_integer(count) = 1 then
		effect(activechannel)(offset+size-1 downto offset) := maxcount(size-1 downto 0);
	elsif effect(activechannel)(offset+size-1 downto offset) < "0" then
		effect(activechannel)(offset+size-1 downto offset) := (OTHERS => '0');
	elsif effect(activechannel)(offset+size-1 downto offset) = "0" and to_integer(count) = 65535  then
		effect(activechannel)(offset+size-1 downto offset) := (OTHERS => '0');
	else
		effect(activechannel)(offset+size-1 downto offset) := effect(activechannel)(offset+size-1 downto offset) + count(size-1 downto 0);
 	end if;
end procedure updateregister;

PROCEDURE gotopage (
	page : IN integer RANGE 0 to numberOfPages;
	outputhead, outputBufferLevel : INOUT integer;
	outputBuffer : INOUT FifOBuffer) is
begin
	REPORT "Page: " & integer'image(page);
	outputBuffer(outputhead) := "01110000"; --p
	outputhead := (outputhead + 1) mod bufferSize;
	outputBufferLevel := (outputBufferLevel + 1);
	outputBuffer(outputhead) := "01100001"; --a
	outputhead := (outputhead + 1) mod bufferSize;
	outputBufferLevel := (outputBufferLevel + 1);
	outputBuffer(outputhead) := "01100111"; --g
	outputhead := (outputhead + 1) mod bufferSize;
	outputBufferLevel := (outputBufferLevel + 1);
	outputBuffer(outputhead) := "01100101"; --e
	outputhead := (outputhead + 1) mod bufferSize;
	outputBufferLevel := (outputBufferLevel + 1);
	outputBuffer(outputhead) := "00100000"; --SPACE
	outputhead := (outputhead + 1) mod bufferSize;
	outputBufferLevel := (outputBufferLevel + 1);
	if page >= 10 then
		--ecode page number(tens)
		outputBuffer(outputhead) := "0011" & std_logic_vector(to_unsigned(page / 10, 4)) ; --0
		outputhead := (outputhead + 1) mod bufferSize;
		outputBufferLevel := (outputBufferLevel + 1);
	end if;

	--decode page number (ones)
	outputBuffer(outputhead) := "0011" & std_logic_vector(to_unsigned(page mod 10, 4)); --0
	outputhead := (outputhead + 1) mod bufferSize;
	outputBufferLevel := (outputBufferLevel + 1);

	outputBuffer(outputhead) := "11111111"; --0xFF
	outputhead := (outputhead + 1) mod bufferSize;
	outputBufferLevel := (outputBufferLevel + 1);
	outputBuffer(outputhead) := "11111111"; --0xFF
	outputhead := (outputhead + 1) mod bufferSize;
	outputBufferLevel := (outputBufferLevel + 1);
	outputBuffer(outputhead) := "11111111"; --0xFF
	outputhead := (outputhead + 1) mod bufferSize;
	outputBufferLevel := (outputBufferLevel + 1);
end PROCEDURE gotopage;

begin
process( Clk, Nrst )
	VARIABLE EqualizerA : effectArray := (
		"00100000100000100000100000100000", --channel 1(0dB, 0dB, 0dB, 0dB, 0dB)
		"00100000100000100000100000100000", --channel 2(0dB, 0dB, 0dB, 0dB, 0dB) 
		"00100000100000100000100000100000", --channel 3(0dB, 0dB, 0dB, 0dB, 0dB)
		"00100000100000100000100000100000", --channel 4(0dB, 0dB, 0dB, 0dB, 0dB)
		"00100000100000100000100000100000", --channel 5(0dB, 0dB, 0dB, 0dB, 0dB)
		"00100000100000100000100000100000"  --channel 6(0dB, 0dB, 0dB, 0dB, 0dB)
	);

	VARIABLE GainA : effectArray := (
		"00000000000000000000000000000000", -- channel 1 (gain, level)
		"00000000000000000000000000000000", -- channel 2 (gain, level)
		"00000000000000000000000000000000", -- channel 3 (gain, level)
		"00000000000000000000000000000000", -- channel 4 (gain, level)
		"00000000000000000000000000000000", -- channel 5 (gain, level)
		"00000000000000000000000000000000"  -- channel 6 (gain, level)
	);

	VARIABLE DelayA	: effectArray := (
		"00000000000000000000000000000000", -- channel 1 (0,01x, 0ms, 1ms)
		"00000000000000000000000000000000", -- channel 2 (0,01x, 0ms, 1ms)
		"00000000000000000000000000000000", -- channel 3 (0,01x, 0ms, 1ms)
		"00000000000000000000000000000000", -- channel 4 (0,01x, 0ms, 1ms)
		"00000000000000000000000000000000", -- channel 5 (0,01x, 0ms, 1ms)
		"00000000000000000000000000000000"  -- channel 6 (0,01x, 0ms, 1ms)
	);

	VARIABLE ReverbA	: effectArray := (
		"00000000000000000000000000000000", -- channel 1 (0ms, 1ms)
		"00000000000000000000000000000000", -- channel 2 (0ms, 1ms)
		"00000000000000000000000000000000", -- channel 3 (0ms, 1ms)
		"00000000000000000000000000000000", -- channel 4 (0ms, 1ms)
		"00000000000000000000000000000000", -- channel 5 (0ms, 1ms)
		"00000000000000000000000000000000"  -- channel 6 (0ms, 1ms)
	);

	VARIABLE VolumeA	: effectArray := (
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000",
		"00000000000000000000000000000000"
	);

	VARIABLE outputrouting : routingArray := (
		"0010011000101000",	--channel 1 (input 3, RCA, +3dB, no link)
		"0010011000101000",	--channel 2 (input 3, RCA, +3dB, no link)
		"0010011000101000",	--channel 3 (input 3, RCA, +3dB, no link)
		"0011011000101000",	--channel 4 (input 4, RCA, +3dB, no link)
		"0011011000101000",	--channel 5 (input 4, RCA, +3dB, no link)
		"0011011000101000"	--channel 6 (input 4, RCA, +3dB, no link)
	);

	VARIABLE pressedFunction 	: integer := 0;
	VARIABLE highlighted 		: integer := 0;
	VARIABLE currentPage 		: integer := 0;
	VARIABLE activeChannel		: integer := 0;
	VARIABLE navMenu			: integer RANGE 0 to 1 := 1;
	VARIABLE updateparameter	: integer RANGE 0 to 1 := 0;
	VARIABLE parameterchanged	: integer RANGE 0 to 1 := 0;
	
	VARIABLE outputhead			: integer RANGE 0 to bufferSize 	:= 0;
	VARIABLE outputtail			: integer RANGE 0 to bufferSize 	:= 0;
	VARIABLE inputhead			: integer RANGE 0 to bufferSize 	:= 0;
	VARIABLE inputBufferLevel 	: integer RANGE 0 to bufferSize 	:= 0;
	VARIABLE outputBufferLevel	: integer RANGE 0 to bufferSize 	:= 0;
	VARIABLE pressState 		: std_logic := '1';
	VARIABLE leftState 			: std_logic := '1';
	VARIABLE rightState 		: std_logic := '1';
	
	VARIABLE touchPage			: integer 	:= 0;
	VARIABLE touchelement		: integer 	:= 0;
	VARIABLE count				: unsigned(31 downto 0) := (others => '0');

	VARIABLE inputBuffer 	: FifOBuffer;
	VARIABLE outputBuffer	: FifOBuffer;
	VARIABLE emptyBuffer	: FifOBuffer := (others => "XXXXXXXX");
	VARIABLE updatepage		: integer	:= 0;
	
	begin
		button <= std_logic_vector(to_unsigned(highlighted, 4));
		if Nrst = '0' THEN
			--reset outputs
			button 		<= "0000";
			TXData 		<= "00000000";
			param1		<= "0000000000000000";
			
			--reset input variables
			pressState 			:= '1';
			leftState 			:= '1';
			rightState 			:= '1';
			pressedFunction 	:= 0;
			highlighted			:= 0;
			currentPage			:= 0;
			activeChannel		:= 0;
			outputhead			:= 0;
			outputtail			:= 0;
			inputhead			:= 0;
			--inputtail			:= 0;
			inputBufferLevel	:= 0;
			outputBufferLevel	:= 0;
			navMenu := 1;
			
		elsif RisING_EDGE(clk) THEN
			--buffer the incoming data
			if Dataready = '1' AND inputBufferLevel < bufferSize THEN
				inputBuffer(inputhead) := RXData;
				inputhead := (inputhead + 1) mod bufferSize;
				inputBufferLevel := inputBufferLevel + 1;
			end if;
			
			--process the incoming data
			if inputhead >=3 THEN
				if inputBuffer(inputhead-1) = "11111111" AND inputBuffer(inputhead-2) = "11111111" AND inputBuffer(inputhead-3) = "11111111" THEN
					if inputBufferLevel >= 7 THEN
						touchPage 	:= to_integer(unsigned(inputBuffer(inputhead-6)));
						if touchPage = outputrouting2 OR touchPage = inputselect2 THEN
							touchElement := to_integer(unsigned(inputBuffer(inputhead-5))) - 5;
						else
							touchElement := to_integer(unsigned(inputBuffer(inputhead-5))) - 2;
						end if;
						pressedFunction := functions(touchPage, touchElement);
						updatepage := 1;
					end if;
					inputBuffer := emptyBuffer;
					inputhead 			:= 0;
					--inputtail 			:= 0;
					inputBufferLevel 	:= 0;
				end if;
			end if;
			
			--press input
			if pressInput = '1' and outputBufferLevel < bufferSize-10 THEN
				pressedFunction := functions(currentPage, highlighted);
				updatepage := 1;
			end if;
			
			--right input
			if rightInput = '1' THEN
				--REPORT "navMenu: " & integer'IMAGE(navMenu);
				if navMenu = 1 THEN
					highlighted := (highlighted + 1) mod functions(currentPage, maxElements-1);
				else
					count := count + "0000000000000001";
					updateparameter := 1;
				end if;
			end if;
			
			--left input
			if leftInput = '1' then
				--REPORT "navMenu: " & integer'IMAGE(navMenu);
				if navMenu = 1 THEN
					if highlighted >= 1 THEN
						highlighted := highlighted - 1;
					else
						highlighted := functions(currentpage, maxElements-1) - 1;
					end if;
				else
					count := count - "0000000000000001";
					updateparameter := 1;
				end if;
			end if;
			
			--function decoder
			if updatePage = 1 THEN
				updatepage := 0;
				highlighted := 0;
				case pressedFunction is
						when homescreen to adjustconfirm => 
							pressedFunction := pressedFunction;

						when channel1 to channel6 => 
							activechannel := pressedfunction - channel1 + 1;
							pressedFunction := outputrouting1;
							
						when RCA1 to USB => 
							outputrouting(activechannel)(14 downto 11) := to_unsigned(pressedFunction - RCA1, 4);
							pressedFunction := signalRouting;

						when CH1 to CH6 => 	
							activeChannel := pressedFunction - 117;
							pressedFunction := effectselect1;

						when gainselect	=> 	
							if activeChannel = 3 OR activeChannel = 4 THEN
								pressedFunction := jackgain;
							else
								pressedFunction := gain;
							end if;		

						when firstCH1 to firstCH6 => 	
							activeChannel := pressedFunction - firstCH1;
							pressedFunction := secondChannel1;
																		
						when secondCH1 to secondCH5	=> 	
							outputrouting(activeChannel)(2 downto 0) := to_unsigned(pressedfunction - secondCH1, 3); 
							pressedFunction := signalRouting;

						when inputgain to chvolume	=>
							navMenu := (navMenu + 1) mod 2;

						when preset1 to preset6	=> 	
							pressedFunction := loadconfirm;

						when changepreset1 to changepreset6	=> 	
							pressedFunction := adjustconfirm;

						when confirmLoad to confirmAdjust	=> 	
							pressedFunction := homescreen;

						when others							=> 	
							pressedFunction := homescreen;

					end case;
				
				if pressedFunction < numberOfPages then
					gotopage(pressedfunction, outputhead, outputBufferLevel, outputBuffer);
					currentPage := pressedfunction;	
				end if;
			end if;
			
			if updateparameter = 1 THEN
				updateparameter := 0;

				case pressedfunction is
					when inputgain =>
						updateregister(outputrouting, 8, 0, pressedfunction, activechannel, count);
						if outputrouting(activechannel)(7 downto 0) > stepsize(pressedFunction - inputgain) THEN
							outputrouting(activechannel)(7 downto 0) := stepsize(pressedFunction - inputgain)(7 downto 0);
						elsif outputrouting(activechannel)(7 downto 0) > stepsize(pressedFunction - inputgain) AND to_integer(count) = 1 THEN
							outputrouting(activechannel)(7 downto 0) := stepsize(pressedFunction - inputgain)(7 downto 0);
						elsif outputrouting(activechannel)(7 downto 0) < "00000000" THEN
							outputrouting(activechannel)(7 downto 0) := "00000000";
						elsif outputrouting(activechannel)(7 downto 0) = "00000000" AND to_integer(count) = 65535 THEN
							outputrouting(activechannel)(7 downto 0) := "00000000";
						else
							parameterchanged := 1;
							outputrouting(activechannel)(7 downto 0) := outputrouting(activechannel)(7 downto 0) + count(7 downto 0);
						end if;

					when f0	 =>
						updateregister(EqualizerA, 6, 0, pressedfunction, activechannel, count);

					when f1	 => 
						updateregister(EqualizerA, 6, 6, pressedfunction, activechannel, count);

					when f2	 => 
						updateregister(EqualizerA, 6, 12, pressedfunction, activechannel, count);

					when f3	 =>  
						updateregister(EqualizerA, 6, 18, pressedfunction, activechannel, count);

					when f4	 =>  
						updateregister(EqualizerA, 6, 0, pressedfunction, activechannel, count);

					when dtime =>   
						updateregister(DelayA, 12, 0, pressedfunction, activechannel, count);

					when feedback =>   
						updateregister(DelayA, 12, 12, pressedfunction, activechannel, count);

					when mix =>   
						updateregister(DelayA, 10, 22, pressedfunction, activechannel, count);

					when rlength =>   
						updateregister(ReverbA, 16, 0, pressedfunction, activechannel, count);

					when rsize =>   
						updateregister(ReverbA, 16, 16, pressedfunction, activechannel, count);

					when channelvolume =>  
						updateregister(VolumeA, 32, 0, pressedfunction, activechannel, count);

					when others =>
				end case;
				count := "00000000000000000000000000000000";
			end if;

			--output the data from the outputBuffer
			case SM_TX is
				when IDLE => if outputBufferLevel > 0 THEN SM_TX <= LOAD; else SM_TX <= IDLE; end if; --if head and tail have the same value there is no data available so then stay in IDLE
				when LOAD => 
					TXData <= outputBuffer(outputtail);	--output the oldest byte in the buffer
					outputtail := (outputtail+1) mod bufferSize;		--increment the tail value
					outputBufferLevel := outputBufferLevel - 1;
					loadByte <= '1';					--let the transmitter know the data is ready					
					SM_TX <= BUSY;
				when BUSY =>
					loadByte <= '0';
					if TXDone = '1' THEN SM_TX <= IDLE; else SM_TX <= BUSY; end if; --if TXDone is high the transmitter has finished transmitting the data so go back to IDLE
				when others => SM_TX <= IDLE;
			end case;
		end if;
	end process;
end RTL;
\end{lstlisting}